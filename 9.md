# পাঠ ৯: জাভা আই/ও

* স্ট্রিম
* বাইট স্ট্রিম
* ক্যারেক্টার স্ট্রিম
* বাফারড স্ট্রিম
* স্ক্যানিং এবং ফরমেটিং
* ডাটা স্ট্রিম
* ইনপুট স্ট্রিম
* আউটপুট স্ট্রিম
* ফাইল
* রিডিং এ টেক্সট ফাইল
* রাইটিং এ টেক্সট ফাইল
* সারসংক্ষেপ

ইনপুট আউটপুট সংক্ষেপে যাকে আমারা বলি আই/ও (I/O) যে কোন কম্পিউটার সিস্টেম বা প্রোগ্রামিং ল্যাংগুজের একটি মৌলিক বিষয়। যে কোন প্রোগ্রাম লিখতে গেলেই আসলে আমাদের আই/ও দরকার হয়। তবে এই বিষয়টি ঠিক ততটা মজার না যতটা অন্যান্য বিষয় গুলো। খানিকটা ইলেক্ট্রিসিটিরর মতো। আমরা জানি প্রত্যেকটি বাড়িতেই এটি আছে, দরজা দিয়ে প্রবেশ করেই আমাদের হাত সুইচবোর্ডের দিকে চলে যায়, আমার সইচ টিপ দিই, এবং লাইট জ্বলে উঠে। এর পেছনের ব্যপারগুলো নিয়ে যেমন ইলেক্ট্রিসিটি কোথা থেকে এলো, কিভাবে কাজ করে এসব নিয়ে আমাদের চিন্তা করতে হয় না। এগুলো নেপথ্যে থেকে ঠিক ঠাক মতো কাজ করে।  আই/ও অনেকটা এরকম। 

তবে একজন জাভা প্রোগ্রামার এর কাছে  আই/ও অনেক গুলো কারণেই গুরুত্বপূর্ণ হতে পারে। জাভাতে অনেক গুলো আই/ও ক্লাস এর কোর এপিআই এর সাথেই থাকে যার বেশির ভাগ – java.io প্যাকেজ-এ। তবে জাভাতে অধিকাংশ ক্ষেত্রেই আই/ও দুই ভাগে ভাগ করা হয়েছে। একটি হলো বাইট ভিত্তিক আই/ও যা input stream এবং output stream দিয়ে হ্যান্ডেল করা হয়, এবং অন্যটি হলো ক্যারেকটার ভিত্তিক যা readers এবং writers দিয়ে হ্যান্ডেল করা হয়। তবে দুই টাইপ-এ অ্যাবস্ট্রাকশন সরবরাহ করে যা দিয়ে সোর্সের সঠিক টাইপ না জেনেও পড়তে বা লিখতে পারি। এতে করে আমরা একি মেথড দিয়ে কনসোল থেকে ডাটা পড়তে পারছি আবার সেই মেথড দিয়ে আমরা নেটওয়ার্ক কানেকশন থেকেও পড়তে পারছি। 

এতো হল টিপ অব দি আইসবার্গ। একবার আমরা  অ্যাবস্ট্রাকশন এ অভ্যস্ত হয়ে গেলে যে কোন সোর্স থেকে ডাটা পড়তে পারবো, আমাদের আসলে খুব একটা কেয়ার করতে হবে না কিভাবে বা কোন সোর্স থেকে ডাটা আসছে বা যাচ্ছে। এখানে একটা গুরুত্বপূর্ণ কথা বলে রাখি, সেটা হলো, জাভা প্রোগ্রামারদের সব থেকে পছন্দের বিষয় হচ্ছে  অ্যাবস্ট্রাকশন। 

অনেক ইন্ট্রোডাকশন হলো, এবার তাহলে আরো ভেতরে প্রবেশ করা যাক। 

শুরুতেই আমরা জেনে নিই, স্ট্রিম কি ? 

## স্ট্রিম

স্ট্রিম হচ্ছে অনেকটা পানির ধারার মতো, একটি উৎস থেকে অবিরাম ভাবে প্রবাহ হচ্ছে এমন কিন্তু আমরা ঠিক ভাবে উৎসে কতটুকু পানি আছে জানি না। অর্থাৎ কনসেপচুয়ালি একটি অবিরাম ডাটা প্রবাহ। আমরা এই প্রবাহ থেকে ডাটা পড়তে বা লিখতে পারি। যে কোন স্ট্রিম একটি উৎস বা গন্তব্যস্থলের সাথে সংযুক্ত। 

স্ট্রিম দুই প্রকার হতে পারে-
1. বাইট স্ট্রিম 
2. ক্যারেকটার স্ট্রিম। 


## বাইট স্ট্রিম

বাইট ভিত্তিক আই/ও নিয়ে কাজ করার জন্যে বাইট স্ট্রিম-এ বেশ সমৃদ্ধ ক্লাস আছে। সাধারণত বাইট স্ট্রিম যে কোন টাইপ অবজেক্ট ( যেমন বাইনারী ডাটা) তে ব্যবহার করা যায়। 
সব বাইট স্ট্রিম এর ক্লাস গুলো InputStream  এবং OutputStream এর সাব ক্লাস। যদিও আরও অনেক বাইট স্ট্রিম ক্লাস আছে, কিন্তু যেহেতু এই দুটি ক্লাস সবার উপরে, আমরা শুরুতেই এই দুটি ক্লাস নিয়েই কথা বলবো। 



 java.io.InputStream এটি একটি অ্যাবস্ট্রাক্ট ক্লাস এবং সকল ইনপুট স্ট্রিম এর সুপার ক্লাস। এতে তিনটি বেসিক মেথড আছে যা কিনা কিভাবে ডাটা স্ট্রিম থেকে পড়তে হয় তা নিয়ে ডিল করে। এছাড়াও স্ট্রিম ক্লোস করা, ফ্লাস করা, এবং কতগুলো বাইট আরও পড়তে হবে ইত্যাদি নিয়ে কিছু মেথড আছে। এগুলো নিয়ে একটি ডিটেইল ব্যাংখ্যা করা যাক। 
read() মেথড: 

```java
public abstract int read() throws IOException
```

এই মেথডটি ১ বাইট unsigned ডাটা পড়ে এবং এর ইন্টিজার ভ্যালু রিটার্ন করে যা কি না  ০ থেকে 255 এর মধ্যে । যদি কোন বাইট না পাওয়া যায় তাহলে এটি -‌1 রিটার্ন করে এবং এতে করে আমরা বুঝতে পারি স্ট্রিম এর ডাটা শেষ হয় গেছে। আমরা একটি উদহারণ দেখি। 

যেহেতু ইনপুট স্ট্রিম একটি অ্যাবস্ট্রাক্ট ক্লাস এবং এর বেশ কিছু সাব ক্লাস আছে, উদাহরণ দেওয়ার সুবিধার্থে আমরা একটি ফাইল ইনপুট স্ট্রিম ব্যবহার করি যা কিনা কোন একটি লোকেশানে রাখা একটি টেক্সট ফাইল পড়তে পারবে ।

প্রথমে আমরা একটি টেক্টট ফাইল তৈরি করে কোন একটি লোকেশানে রাখি। সাধারণত প্রজেক্ট এর একটি ফোল্টার তৈরি করে তাতেও রাখা যেতে পারে। 

এর পর এই ফাইল এ যে কোন একটি স্ট্রিং লিখি। এখানে আমার ফাইল এর নাম input.txt  এতে নিচের লাইটি লিখেছি - 
`The quick brown fox jumps over the lazy dog.`

এবার নিচের কোডটি রান করি। 

```java
package com.company;

import java.io.FileInputStream;
import java.io.IOException;

public class Main {

    public static void main(String[] args) {
        FileInputStream in = null;

        try {
            in = new FileInputStream("input.txt");
            int c;

            while ((c = in.read()) != -1) {
                System.out.print(c + ",");
            }

        } catch (IOException e) {
            System.err.println("Could not read file");
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e1) {
                    System.err.println("Could close input stream");
                }
            }
        }
    }
}
```

আমরা এখানে শুরুতে একটি `FileInputStream` ক্লাস এর ইনস্টেন্স ক্রিয়েট করেছি তারপর আর্গুমেন্ট হিসেবে আমাদের টেক্সট ফাইলটির লোকেশান দিয়েছি। 
তারপর একটা  `int c` ডিক্লেয়ার করেছি ।
এর হুয়াইল লুপটিতে আমারা প্রতিবার একটি করে বাইট রিড করে `c` তে এসাইন করছি এবং তা প্রিন্ট আউট করছি। এই লুপটি ততক্ষণ পর্যন্ত চলবে যতক্ষণ পর্যন্ত `read()` মেথডটি` -1` রিটার্ণ না করে। ফাইল টি পড়া শেষ হয়ে গেলে এটি `-1` রিরার্ণ করবে। 
কোডটি একটি ট্রাই ক্যাচ ব্লক এর মধ্যে কারণ আমার জানি যে আই/ও আছে খুব লো লেভেল থেকে কাজ করে । এর মাঝে কোন একটি সমস্য হতেই পারে এবং তা হলে জাবা `IOException`  থ্রু করবে এবং তা যাতে আমরা হ্যান্ডেল করতে পারি। 
এছাড়াও একটি ফাইনালি ব্লক আছে  যেখানে আমরা স্ট্রিমটি বন্ধ করেছি। আমাদের খেয়াল রাখতে হবে যে, যখনি একটি স্ট্রিম এর কাজ শেষ হয়ে যাবে তখনি তা বন্ধ করে দিতে হবে। এটি অনেকটা আমাদের ওয়াশরুমের পানির টেপ এর মতো। কাজ শেষ হলে আমরা অফ করে দিই যাতে করে রিসোর্স নষ্ট না হয়। 

এখন উপরের কোডটি যদি রান করি তাহলে কনসোলে আমরা নিচের আউটপুটটি দেখতে পাবো- 
```
84,104,101,32,113,117,105,99,107,32,98,114,111,119,110,32,102,111,120,32,106,117,109,112,115,32,111,118,101,114,32,116,104,101,32,108,97,122,121,32,100,111,103,46,
```

এর কারণ হচ্ছে `read()` মেথডটি এক সাথে একটি বাইট পড়ে এবং এর ইন্টিজার রিপ্রেজেন্টেশান রিটার্ণ করে। আমরা যদি একে ঠিক আমাদের `input.txt` এর স্ট্রিং এর মতো করে প্রিণ্ট করতে চাই তাহলে ইন্টিজারকে ক্যারেকটার এ কাস্ট করতে হবে। 

```java
System.out.print((char)c);
```





## চলবে ....
